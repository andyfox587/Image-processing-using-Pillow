2
import os
import io
from PIL import Image, ImageSequence, ImageOps

def resize_frame(frame, size, opacity=1.0, greyscale=False):
    """Resize and optionally convert to greyscale a single frame"""
    frame = frame.convert('RGBA').resize((size, size), Image.LANCZOS)
    if greyscale:
        # Convert to greyscale while preserving alpha channel
        alpha = frame.split()[3]
        grey = ImageOps.grayscale(frame.convert('RGB'))
        frame = grey.convert('RGBA')
        frame.putalpha(alpha)
    if opacity < 1.0:
        alpha = frame.split()[3]
        alpha = alpha.point(lambda p: int(p * opacity))
        frame.putalpha(alpha)
    return frame

def optimize_image_size(img, max_size_kb, format='PNG'):
    """Optimize image to meet size requirements"""
    quality = 95
    buffer = io.BytesIO()

    while quality > 5:
        buffer.seek(0)
        buffer.truncate()
        img.save(buffer, format=format, optimize=True, quality=quality)
        if buffer.tell() / 1024 <= max_size_kb:
            break
        quality -= 5

    return buffer.getvalue() if buffer.tell() > 0 else None

def process_animated_gif(img, output_path, size, max_size_kb):
    """Process animated GIF while maintaining size constraints"""
    frames = []
    durations = []

    for frame in ImageSequence.Iterator(img):
        duration = frame.info.get('duration', 100)
        frame = resize_frame(frame, size)
        frames.append(frame)
        durations.append(duration)

    # Save with optimization
    buffer = io.BytesIO()
    frames[0].save(
        buffer,
        save_all=True,
        append_images=frames[1:],
        format='GIF',
        optimize=True,
        duration=durations,
        loop=0
    )

    if buffer.tell() / 1024 > max_size_kb:
        # If still too large, reduce colors
        for frame in frames:
            frame = frame.quantize(colors=128, method=Image.MAXCOVERAGE)

    frames[0].save(
        output_path,
        save_all=True,
        append_images=frames[1:],
        format='GIF',
        optimize=True,
        duration=durations,
        loop=0
    )

def convert_image(input_path, output_dir, size, output_format, max_size_kb, 
                 suffix='', opacity=1.0, greyscale=False):
    """Convert a single image with size and format constraints"""
    try:
        with Image.open(input_path) as img:
            is_animated = getattr(img, "is_animated", False)
            base_name = os.path.splitext(os.path.basename(input_path))[0]
            new_filename = f"{base_name}_{size}x{size}{suffix}.{output_format.lower()}"
            output_path = os.path.join(output_dir, new_filename)

            if output_format.lower() == 'gif' and is_animated:
                process_animated_gif(img, output_path, size, max_size_kb)
            else:
                img = resize_frame(img, size, opacity, greyscale)

                # Save with size optimization
                image_data = optimize_image_size(img, max_size_kb, output_format)
                if image_data:
                    with open(output_path, 'wb') as f:
                        f.write(image_data)
                else:
                    # Fallback to direct save if optimization fails
                    img.save(output_path, format=output_format, optimize=True)

            print(f"Created: {output_path}")
    except Exception as e:
        print(f"Error processing {input_path}: {str(e)}")

def process_images(input_folder, mode, icon_image):
    """Process all images in the input folder based on mode (Stickers/Stamps)"""
    input_folder_name = os.path.basename(input_folder)
    output_folder_name = f"{input_folder_name}_Output"
    output_base_dir = os.path.join(input_folder, "..", output_folder_name)

    # Define output directories based on mode
    output_dirs = {
        '240': os.path.join(output_base_dir, "output_240x240"),
        '360': os.path.join(output_base_dir, "output_360x360"),
        '720': os.path.join(output_base_dir, "output_720x720"),
        'icon': os.path.join(output_base_dir, "output_icon")
    }

    if mode == 'stamps':
        output_dirs['1480'] = os.path.join(output_base_dir, "output_1480x1480")

    # Create output directories
    for dir_path in output_dirs.values():
        os.makedirs(dir_path, exist_ok=True)
        print(f"Created directory: {dir_path}")

    # Process all images
    for filename in os.listdir(input_folder):
        if filename.lower().endswith(('.png', '.gif')):
            input_path = os.path.join(input_folder, filename)

            # Common conversion (240x240 PNG)
            convert_image(input_path, output_dirs['240'], 240, 'PNG', 290)

            # Mode-specific conversions
            if mode == 'stickers':
                convert_image(input_path, output_dirs['360'], 360, 'GIF', 290)
                convert_image(input_path, output_dirs['720'], 720, 'GIF', 500)
            else:  # stamps
                convert_image(input_path, output_dirs['360'], 360, 'PNG', 1024)
                convert_image(input_path, output_dirs['720'], 720, 'PNG', 1024)
                convert_image(input_path, output_dirs['1480'], 1480, 'PNG', 1024)

            # Process icon image
            if input_path == icon_image:
                convert_image(input_path, output_dirs['icon'], 144, 'PNG', 290, suffix='_color')
                convert_image(input_path, output_dirs['icon'], 144, 'PNG', 290, 
                            suffix='_grey', greyscale=True)
                convert_image(input_path, output_dirs['icon'], 512, 'PNG', 290)
                if mode == 'stickers':
                    convert_image(input_path, output_dirs['icon'], 280, 'GIF', 290)

def main():
    # Get base directory
    repl_dir = os.path.join(os.getcwd(), "Repl")
    if not os.path.exists(repl_dir):
        print("Error: 'Repl' directory not found in current working directory.")
        return

    # Get mode selection
    while True:
        print("\nSelect processing mode:")
        print("1. Stickers")
        print("2. Stamps")
        choice = input("Enter your choice (1 or 2): ").strip()
        if choice in ('1', '2'):
            mode = 'stickers' if choice == '1' else 'stamps'
            break
        print("Invalid choice. Please enter 1 or 2.")

    # Get available folders (excluding _Output folders)
    folders = [d for d in os.listdir(repl_dir) 
              if os.path.isdir(os.path.join(repl_dir, d)) and not d.endswith('_Output')]

    if not folders:
        print("No valid folders found in Repl directory.")
        return

    # Display folder options
    print("\nAvailable folders:")
    for i, folder in enumerate(folders, 1):
        print(f"{i}. {folder}")

    # Get folder selection
    while True:
        try:
            choice = int(input("\nEnter the number of the folder to process: "))
            if 1 <= choice <= len(folders):
                selected_folder = folders[choice - 1]
                break
            print("Invalid choice. Please enter a valid number.")
        except ValueError:
            print("Please enter a valid number.")

    input_folder = os.path.join(repl_dir, selected_folder)

    # Get list of images for icon selection
    images = [f for f in os.listdir(input_folder) 
             if f.lower().endswith(('.png', '.gif'))]

    if not images:
        print("No images found in selected folder.")
        return

    # Display image options
    print("\nSelect an image to use as the Application Icon:")
    for i, img in enumerate(images, 1):
        print(f"{i}. {img}")

    # Get icon selection
    while True:
        try:
            choice = int(input("\nEnter the number of the image to use as icon: "))
            if 1 <= choice <= len(images):
                icon_image = os.path.join(input_folder, images[choice - 1])
                break
            print("Invalid choice. Please enter a valid number.")
        except ValueError:
            print("Please enter a valid number.")

    # Process the images
    print(f"\nProcessing images in folder: {selected_folder}")
    process_images(input_folder, mode, icon_image)
    print("\nConversion complete!")

if __name__ == "__main__":
    main()
